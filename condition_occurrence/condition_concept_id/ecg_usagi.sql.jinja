WITH cte AS (
  SELECT
    DISTINCT CONCAT("HASH_",FARM_FINGERPRINT(ecg.diagnosis)) AS sourceCode,
    REGEXP_REPLACE(ecg.diagnosis,'(\n|\r|\t)+','_') AS sourceName,
    COUNT(*) AS sourceFrequency,
    COALESCE(muse.conceptId,0) AS conceptId,
    COALESCE(muse.conceptName, 'Unmapped') AS conceptName,
  FROM `{{project-id}}.{{dataset-id-raw-3}}.ecg_diagnosis` ecg
  LEFT JOIN UNNEST(ecg.codes.list) c
  LEFT JOIN `{{project-id}}.{{dataset-id-raw-3}}.muse_codes_usagi` muse
  ON c.item = muse.sourceCode
  GROUP BY sourceCode, sourceName, conceptId, conceptName
), cte_mapped AS (
  SELECT     *
  FROM cte
  WHERE conceptId <> 0 
), cte_unmapped AS (
  SELECT *
  FROM cte
  WHERE conceptId = 0
    AND sourceCode NOT IN (SELECT sourceCode FROM cte_mapped) 
), ecg_raw AS (
  SELECT *
  FROM cte_mapped
  UNION DISTINCT
  SELECT *
  FROM cte_unmapped
)
SELECT DISTINCT 
  sourceCode,
  sourceName,
  raw.sourceFrequency,
  CAST(NULL AS string) AS sourceAutoAssignedConceptIds,
  1 AS matchScore,
  IF(master.mappingStatus = "APPROVED", master.mappingStatus, "UNCHECKED") AS mappingStatus,
  IF(master.mappingStatus = "APPROVED", master.equivalence, "UNREVIEWED") AS equivalence,
  IF(master.mappingStatus = "APPROVED", master.statusSetBy, 'etl') AS statusSetBy,
  UNIX_MILLIS(CURRENT_TIMESTAMP()) AS statusSetOn,
  IF(master.mappingStatus = "APPROVED", master.conceptId, COALESCE(raw.conceptId,0)) AS conceptId,
  IF(master.mappingStatus = "APPROVED", master.conceptName, COALESCE(raw.conceptName, 'Unmapped')) AS conceptName,
  IF(master.mappingStatus = "APPROVED", master.domainId, CAST(NULL AS string)) AS domainId,
  IF(master.mappingStatus = "APPROVED", master.mappingType, 'MAPS_TO') AS mappingType,
  IF(master.mappingStatus = "APPROVED", master.comment, '') AS comment,
  IF(master.mappingStatus = "APPROVED", master.createdBy, 'etl') AS createdBy,
  UNIX_MILLIS(CURRENT_TIMESTAMP()) AS createdOn,
  CAST(NULL AS string) AS assignedReviewer
FROM ecg_raw raw
LEFT JOIN `{{project-id}}.{{dataset-id-usagi}}.ecg_usagi` master
USING (sourceCode, sourceName)
WHERE lower(sourceName) not like 'confirmed%'
ORDER BY sourceFrequency DESC, sourceCode ASC